<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Content Manager</title>
  <script src="https://identity.netlify.com/v1/netlify-identity-widget.js"></script>
</head>
<body>
  <!-- Include the script that builds the page and powers Netlify CMS -->
  <script src="https://unpkg.com/netlify-cms@^2.0.0/dist/netlify-cms.js"></script>
  <script>
   CMS.registerPreviewStyle("/css/main.css");
   var RelationWrappedControl = window.createClass({

     handleChange: function handleChange(newVals, metadata) {
       if (newVals !== this.props.value) {
         this.props.onChange(newVals, metadata);
       }
     },

     render: function render() {
       const valuetoRender = this.props.value && typeof this.props.value.toJS === 'function'
                           ? this.props.value.toJS()
                           : this.props.value || '';

       // get the standard relation widget
       const relationWidget = window.CMS.getWidget('relation').control;

       // render everything
       return window.h(
         'div',
         {
           className: this.props.classNameWrapper,
         },
         [
           window.h(
             'strong',
             {},
             'Current Value/s:',
           ),
           window.h(
             'p',
             {},
             (Array.isArray(valuetoRender) && valuetoRender.join(' | ')) || valuetoRender || 'NOTHING SELECTED',
           ),
           window.h(
             relationWidget,
             {
               ...this.props,
               // we use the component almost as is, but capture it's onChange value
               onChange: this.handleChange,
               // because we hijacked onChange we need to update the value ourselves!
               value: this.props.value || '',
             },
           ),
         ],
       );
     },
   });

    window.CMS.registerWidget('relationWrapped', RelationWrappedControl);
  </script>
  </script>

</body>
</html>
